import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# React

We provide officially-supported React bindings for `signia` in two packages:

- `signia-react` provides hooks for creating and consuming signals in functional components.
  - [`useAtom`](docs/API/signia_react/functions/useAtom) - A hook for creating atomic signals.
  - [`useComputed`](docs/API/signia_react/functions/useAtom) - A hook for creating computed signals.
  - [`track`](docs/API/signia_react/functions/useAtom) - component wrapper for automatically tracking signal value access and re-rendering the wrapped component if the signals' values change.
  - [`useValue`](docs/API/signia_react/functions/useAtom) - A hook for manually tracking signal value access (not required if you use `track`)
- `signia-react-jsx` provides a minimal global jsx integration for use with TypeScript's `jsxImportSource` option. This causes all functional components to be automatically
  rerendered when the values of any signals they use change.

## Installing the Bindings

:::note

- These bindings require a JS environment that supports [`Proxy`](https://caniuse.com/?search=Proxy).
- These bindings not currently work with legacy [class components](https://beta.reactjs.org/reference/react/Component). We may be willing to add and maintain legacy support if there is suffient demand. Let us know!

:::

<Tabs>
	<TabItem value="npm" label="npm">
		<pre>npm add signia-react</pre>
	</TabItem>
	<TabItem value="yarn" label="yarn">
		<pre>yarn add signia-react</pre>
	</TabItem>
	<TabItem value="pnpm" label="pnpm">
		<pre>pnpm add signia-react</pre>
	</TabItem>
</Tabs>

If you are using TypeScript and you wish to use the `@computed` decorator, make sure to enable [experimental decorators](https://www.typescriptlang.org/tsconfig#experimentalDecorators). As soon as TypeScript 5.0 is released we will also add support for the new standard decorators.

### Automatic component tracking

If you wish to enable tracking on all functional components automatically, run:

<Tabs>
	<TabItem value="npm" label="npm">
		<pre>npm add signia-react-jsx</pre>
	</TabItem>
	<TabItem value="yarn" label="yarn">
		<pre>yarn add signia-react-jsx</pre>
	</TabItem>
	<TabItem value="pnpm" label="pnpm">
		<pre>pnpm add signia-react-jsx</pre>
	</TabItem>
</Tabs>

And then add these lines to your app's entry file

```ts
import { install } from 'signia-react-jsx'
install()
```

## Usage

### Writing reactive components

:::tip
If you are using `signia-react-jsx`, feel free to skip this section. Your components are already reactive! âœ¨
:::

We recommend using `track` to wrap all components that use signals following this pattern:

```ts
type MyComponentProps = { foo: Bar }
const MyComponent = track(function MyComponent(props: MyComponentProps) {
	// ...
})
```

If you are unable to use `track`, you should make sure that any usages of signals are wrapped by a `useValue`

```ts
type MyComponentProps = { foo: Signal<Bar> }
const MyComponent: React.FC<MyComponentProps> = (props: MyComponentProps) => {
	const foo: Bar = useValue(props.foo)
	// ...
}
```

If a signal is being used indirectly you can pass a 'compute' function to `useValue`.

```ts
type MyComponentProps = { getFoo: (n: number) => Bar }
const MyComponent: React.FC<MyComponentProps> = (props: MyComponentProps) => {
	// getFoo uses a signal under the hood, but we don't have direct access to that signal.
	const n = 42
	const foo: Bar = useValue('foo', () => props.getFoo(42), [props.getFoo, n])
	// ...
}
```

### Managing shared state

We recommend keeping high-level shared state and logic in a class, or a set of linked classes.

```ts
import { atom } from 'signia'

class Document {
	private readonly state = atom('Document.state', {
		title: 'Page 1',
		body: 'words etc',
	})
	readonly stylePanel = new StylePanel(this)

	setTitle(title: string) {
		this.state.update((state) => ({ ...state, title }))
	}

	setBody(body: string) {
		this.state.update((state) => ({ ...state, body }))
	}
}

class StylePanel {
	constructor(private document: Document) {}

	private readonly state = atom('StylePanel.state', {
		fontSize: 12,
		color: 'black',
	})

	increaseFontSize() {
		this.state.update((state) => ({ ...state, fontSize: state.fontSize + 1 }))
	}
}
```

Then creating a hook to instantiate it when your app initializes:

```ts
const useNewDocument = () => useMemo(() => new Document(), [])

const App = () => {
	const doc = useNewDocument()

	// ...
}
```

You can either pass the doc around in props or use [context](https://beta.reactjs.org/learn/passing-data-deeply-with-context) to make it more easily accessible without prop drilling.

We prefer to use context:

```ts
const DocumentContext = React.createContext<Document | null>(null)

const useDocument = () => {
	const doc = useContext(DocumentContext)
	if (!doc) throw new Error('No document found in context')
	return doc
}

const App = () => {
	const doc = useNewDocument()

	return (
		<DocumentContext.Provider value={doc}>
			{/* ... the rest of the app ... */}
		</DocumentContext.Provider>
	)
}
```

### Managing local state

`useAtom` can help you manage component-local state in a similar way to `useState`.

```diff
 const Counter = track(function Counter () {
-  const [count, setCount] = useState(0)
+  const count = useAtom('count', 0)

-  const increment = useCallback(() => setCount(count + 1), [count])
+  const increment = useCallback(() => count.set(count.value + 1), [])

-  return <button onClick={increment}>The count is {count}</button>
+  return <button onClick={increment}>The count is {count.value}</button>
 })
```

In this example, `count` will never change and `count.value` will always be up to date, so **you never need to worry about stale values in closures**.

You can think of `useAtom` as a 'reactive' version of `React.useRef`.

### Avoiding unwanted re-renders

Signals are as fine-grained as you make them.
Very often you might have a signal that contains an object, but you only care about part of the object.

```ts
class Document {
	state = atom('Document.state', { title: 'Page 1', body: 'words etc' })

	setTitle(title: string) {
		this.state.update((state) => ({ ...state, title }))
	}

	setBody(body: string) {
		this.state.update((state) => ({ ...state, body }))
	}
}

const DocumentTitle = track(function DocumentTitle({ doc }: { doc: Document }) {
	return <h1>{doc.state.value.title}</h1>
})
```

In this example, every time `setBody` is called it will cause the `DocumentTitle` component to re-render, even though it does not use the body text. This is because there is only one signal at play here: the atom for the whole document state. `DocumentTitle` accesses that signal directly so it rerenders any time the whole document state changes.

To get around this, you can create a computed signal to 'select' the part of the state you care about. There are a number of ways to do that:

1. **[recommmended]** Use the `@computed` annotation in the `Document` class

   ```ts
   class Document {
   	private readonly state = atom('Document.state', {
   		title: 'Page 1',
   		body: 'words etc',
   	})

   	@computed get title() {
   		return this.state.value.title
   	}
   }

   const DocumentTitle = track(function DocumentTitle({ doc }: { doc: Document }) {
   	return <h1>{doc.title}</h1>
   })
   ```

2. Extract the title with `useValue`.

   ```ts
   const DocumentTitle: React.FC<{ doc: Document }> = ({ doc }) => {
   	const title = useValue('title', () => doc.state.value.title, [doc])
   	return <h1>{title}</h1>
   }
   ```

3. Extract the title with `useComputed`.

   ```ts
   const DocumentTitle = track(function DocumentTitle({ doc }: { doc: Document }) {
   	const title = useComputed('title', () => doc.state.value.title, [doc])
   	return <h1>{title.value}</h1>
   })
   ```
