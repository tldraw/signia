# What are signals?

Let's start with an extremely broad definition:

**A signal is a value that changes over time and whose change events can trigger side effects**.

There are many well-known software patterns matching this description, but that we wouldn't normally call 'signals'. For example, you could argue that React is a signals library specifically for UI view trees.

This might seem like a trivial definition, but it's a useful one to explore. There are many implementations of signals, and many different names used for the same underlying conecepts.

Let's break signals down to understand their component parts. This will help us see what different signals libraries share despite their implementation differences. And we can understand how familiar architectures, like React, are built on the same patterns.

## Breaking signals down

Signals libraries or frameworks are typically based on three primitives:

- Root values

  A root value is any state value that is updated directly, normally in response to external events, e.g. user input.

  :::info
  In a modern idiomatic React app, `useState` or `useReducer` are for managing root values.
  :::

- Derived values

  A derived value is any state value that is computed exclusively by looking at other state values.

  :::info
  In a React component, the rendered tree is a derived value. Any intermediate data you compute during a component's render function is also derived, e.g. a filtered list of todo items in a todo app.
  :::

- Side effects

  A side effect is any process which runs in response to a state change event.

  :::info
  In React, updating the DOM is a side effect which is managed by React itself. It also provides `useEffect` for executing custom side effects in response to changing values.
  :::

import ThemedImage from '@theme/ThemedImage'
import useBaseUrl from '@docusaurus/useBaseUrl'

<ThemedImage
	alt="How signals work"
	sources={{
		light: useBaseUrl('/img/what-are-signals-0-light.svg'),
		dark: useBaseUrl('/img/what-are-signals-0-dark.svg'),
	}}
/>

On top of this foundation there exists a wide spectrum of variables that give flavor to each particular signals implementation. Here's just a few:

### How do you access the value of a signal?

- Are the signals explicitly wrapped?
- Does a compiler do the unwrapping on your behalf?
- If not, is it `get(wrapper)` or `wrapper.value` or `wrapper.get()`?
  <br />
  <br />

:::info
In React this is complicated. Values are unwrapped and can be tricky to read depending on where they are defined, e.g. folks frequently accidentally read stale values.
:::

### How are root state changes propagated?

There are two main approaches: **push** and **pull**.

Generally speaking **pull** is simpler to work with because things are computed _lazily_ which can avoid unwanted extra recomputation. However, in some situations **push** can be more performant because it has lower overhead.

#### Push

When you change a root value, any derived values that read from it are immediately updated, and so on, from left to right.

<ThemedImage
	alt="Push signals"
	sources={{
		light: useBaseUrl('/img/what-are-signals-push-light.svg'),
		dark: useBaseUrl('/img/what-are-signals-push-dark.svg'),
	}}
/>

1. The root value is updated.
2. The derived value is updated.
3. The next derived value is updated.
4. The side effect is triggered.

#### Pull

When you change a root value, any side effects that might need to execute are notified. Upstream values are only recomputed
if they need to be.

<ThemedImage
	alt="Push signals"
	sources={{
		light: useBaseUrl('/img/what-are-signals-pull-light.svg'),
		dark: useBaseUrl('/img/what-are-signals-pull-dark.svg'),
	}}
/>

1. The root value is updated
2. The side effect is 'maybe' triggered
3. The `<TodoList>` value is 'maybe' recomputed
4. The `Active todos` value is recomputed
5. The `<TodoList>` value is recomputed
6. The side effect is triggered

### How are derived values created and cached?

- Explicit dependency declaration?
- Automatic dependency capturing?

### Other concerns

- What kinds of side effects can be triggered?
  - Only UI updates, or any old side effect?
- Are the signals standalone, bolted on to a framework, or integrated into a framework from the ground up?
- Can the signals form a tree, a directed acyclic graph, or a directed cyclic graph?

## What problems do signals solve?

Generally speaking, the primary benefit of signals is that they provide a consistent, automated way to manage derived state and side effects. This
